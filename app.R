# Tyler Therron
# Winter Lab Macrophage Genomics - Rheumatology Department - Feinberg School of Medicine
# Group File Maker App for Winter Lab Database of Bulk RNA-sequencing Database (v2)
# 2025/12/02

suppressPackageStartupMessages({
  library(shiny)
  library(DT)
  library(dplyr)
  library(tidyr)
  library(stringr)
  library(readr)
  library(colourpicker)
  library(jsonlite)
  library(plotly)
})

options(shiny.maxRequestSize = 1000 * 1024^2)

`%||%` <- function(x, y) {
  if (is.null(x) || (is.character(x) && length(x) == 0)) y else x
}

# ----------------------- Helpers ----------------------- #

fallback_palette <- function(n){
  hues <- seq(15, 375, length = n + 1)
  grDevices::hcl(h = hues, l = 65, c = 100)[1:n]
}

# ----------------------- UI ----------------------- #


ui <- fluidPage(
  tags$head(
    tags$style(HTML("
    /* Wrapper for the info icon */
    .upload-help-wrapper {
      position: relative;
      display: inline-block;
      margin-left: 6px;
      cursor: pointer;
    }

    /* Only the icon is blue, not the text inside the card */
    .upload-help-wrapper i {
      font-size: 20px;
      color: #0d6efd;
    }

    /* The hover card itself */
    .upload-help-card{
      display: block;          /* <-- key */
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    
      position: absolute;
      top: 0;
      left: 26px;
      z-index: 2000;
    
      width: 720px;
      max-width: min(90vw, 780px);
      max-height: 720px;
      overflow: auto;
    
      background: #ffffff;
      border-radius: 10px;
      border: 1px solid #e5e5e5;
      box-shadow: 0 6px 18px rgba(0,0,0,0.18);
      padding: 14px 18px;
      color: #000000;
    }


    .upload-help-card p {
      font-size: 16px;
      line-height: 1.45;
      color: #000000;
      margin-bottom: 10px;
    }

    .upload-help-card table {
      font-size: 15px;
      color: #000000;
    }

    .upload-help-card th {
      font-weight: 600;
    }

    /* Show card on hover */
    .upload-help-wrapper:hover .upload-help-card {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
    }
  "))
  ),
  
  titlePanel("Winter Lab Bulk RNA-seq: Groupfile Builder (v2)"),
  tags$head(
    tags$meta(name = "viewport", content = "width=device-width, initial-scale=1")
  ),
  tags$head(
    tags$style(HTML("
    /* Make plotly + DT behave nicely on small screens */
    .plot-container, .js-plotly-plot, .plotly, .datatables { width: 100% !important; }

    /* Responsive: stack sidebar above main on small screens */
    @media (max-width: 768px) {
      .container-fluid { padding-left: 10px; padding-right: 10px; }
      .col-sm-4, .col-sm-8 { width: 100% !important; float: none !important; }
      .sidebar { margin-bottom: 12px; }
      .form-control, .selectize-control { font-size: 16px; } /* prevents iOS zoom-on-focus */
    }

    /* Make DT wrapper horizontally scroll if needed */
    div.dataTables_wrapper { width: 100%; overflow-x: auto; }
  "))
  ),
  
  tags$hr(),
  
  sidebarLayout(
    sidebarPanel(width = 4,
                 # h4("1) Upload dataset"),
                 div(
                   style = "display:flex; align-items:center; gap:6px;",
                   h4("1) Upload dataset"),
                   
                   # ✅ use div wrapper (not span) and keep tableOutput as-is
                   tags$div(
                     class = "upload-help-wrapper",
                     icon("info-circle"),
                     
                     tags$div(
                       class = "upload-help-card",
                       tags$p(
                         "When uploading a CPM or FPKM normalized bulk RNA-sequenced dataset, ",
                         "it should follow the template column layout shown below."
                       ),
                       tags$div(
                         style = "display:flex; justify-content:center; margin-bottom:8px;",
                         tableOutput("template_Dataset_hover")
                       ),
                       
                       tags$p("The output groupfile generated by this app will have the structure below."),
                       tags$div(
                         style = "display:flex; justify-content:center; width:100%; margin-bottom:8px;",
                         tableOutput("template_Output_hover")
                       ),
                       
                       tags$p(
                         "Workflow: upload your dataset, choose where sample columns begin, ",
                         "define/nickname groups and colors, then use token rules or manual edits ",
                         "to assign each sample before downloading the final CSV."
                       )
                     )
                   )
                 ),
                 fileInput(
                   "expression_dataframe", "Choose CSV file",
                   accept = c(".csv","text/csv","text/plain")
                 ),
                 
                 helpText("Input where the sample column(s) begin: "),
                 
                 numericInput(
                   "data_start_col",
                   "Sample data starts at column #",
                   value = 3,
                   min = 1,
                   step = 1
                 ),
                 helpText("Numbered Column Preview from Data File: "),
                 uiOutput("data_start_preview"),
                 
                 tags$hr(),
                 
                 uiOutput("gene_label_ui"),
                 tags$hr(),
                 
                 h4("2) Define groups & colors"),
                 numericInput("n_groups", "Number of groups", value = 2, min = 1, step = 1),
                 uiOutput("group_name_color_ui"),
                 tags$hr(),
                 
                 h4("3) Grouping method"),
                 radioButtons(
                   "group_mode", NULL,
                   choices = c("Token-based (auto)" = "token",
                               "Manual table"       = "manual"),
                   selected = "token"
                 ),
                 conditionalPanel(
                   condition = "input.group_mode == 'token'",
                   checkboxGroupInput(
                     "token_delims",
                     "Split sample names on:",
                     choices  = c("underscore (_)" = "_",
                                  "dash (-)"      = "-",
                                  "dot (.)"       = ".",
                                  "space"         = " "),
                     selected = c("_", "-")   # sensible default
                   ),
                   tags$div(
                     style = "font-size:16px; line-height:1.35; padding:10px 12px; background:#f7f7f7; border:1px solid #e5e5e5; border-radius:10px; margin:8px 0;",
                     tags$b("How token grouping works (AND vs OR):"),
                     # tags$ul(
                     #   style = "margin:8px 0 0 18px;",
                     #   tags$li(tags$b("All tokens (AND): "), "A sample is assigned to this group only if it contains ", tags$u("every"), " selected token. ",
                     #           tags$span(style="color:#333;", "Example: tokens = CD11c + C8 + O → sample must include all three.")),
                     #   tags$li(tags$b("Any token (OR): "), "A sample is assigned to this group if it contains ", tags$u("at least one"), " selected token. ",
                     #           tags$span(style="color:#333;", "Example: tokens = MRL or SLE → sample can include either token."))
                     # ),
                     tags$div(
                       style = "font-size:16px; line-height:1.35; padding:10px 12px; background:#f7f7f7; border:1px solid #e5e5e5; border-radius:10px; margin:8px 0;",
                       tags$b("How token grouping works:"), 
                       tags$ul(
                         style = "margin:8px 0 0 18px;",
                         tags$li(
                           tags$b("All tokens (AND) only: "),
                           "A sample is assigned to a group only if its name contains ",
                           tags$u("every"),
                           " selected token for that group. ",
                           tags$span(
                             style="color:#333;",
                             "Example: tokens = CD11c + C8 + O → sample name must include all three."
                           )
                         )
                       )),
                     tags$div(
                       style = "margin-top:8px;",
                       tags$b("If multiple groups match: "),
                       "the app chooses the most specific rule (AND with more tokens wins). If still tied, the top-most group wins."
                     )
                   ),
                   uiOutput("token_group_selectors"),
                   actionButton("apply_token", "Apply token grouping")
                 ),
                 
                 tags$hr(),
                 fluidRow(
                   column(
                     7,
                     downloadButton("download_groupfile", "Download groupfile (Sample,Group,Color)", width = "100%")
                   ),
                   column(
                     5,
                     textInput(
                       "groupfile_name",
                       label = NULL,
                       placeholder = "Optional filename (no .csv needed)"
                     )
                   )
                 )
    ),
    
    mainPanel(width = 8,
              tabsetPanel(id = "tabs",
                          tabPanel("Assignment table",
                                   br(),
                                   tags$p(
                                     "Assign groups with token-based auto-fill, then fine-tune here. Multi-select rows and apply a group in bulk.",
                                     style = "font-size:16px; color:#000000; font-weight:600; margin-bottom:8px;"
                                   ),
                                   fluidRow(
                                     column(
                                       6,
                                       selectInput(
                                         "bulk_group",
                                         "Set selected rows to group (or Unassign)",
                                         choices = NULL
                                       )
                                     ),
                                     column(6, actionButton("apply_bulk", "Apply to selected"))
                                   ),
                                   DTOutput("assign_dt")
                          ),
                          tabPanel("Visualization preview",
                                   br(),
                                   helpText("Quick QC: boxplots using your current group assignments and colors."),
                                   uiOutput("viz_gene_ui"),
                                   div(
                                     plotlyOutput("viz_plot", height = "900px", width = "85%")
                                   )
                          )
              )
    )
  )
)

# ----------------------- Server ----------------------- #

server <- function(input, output, session){
  
  UNASSIGNED_SENTINEL <- "<UNASSIGNED>"
  
  # grp_tokens_rv <- reactiveVal(list())  # named list: GroupName -> character vector of tokens
  grp_rule_rv <- reactiveVal(list())
  # structure: list("Group 1" = list(tokens = c("MRL","SLE"), mode="any"), ...)
  
  template_data <- readr::read_csv(
    "./template_webApp_data.csv",
    show_col_types = FALSE
  )
  
  
  template_output <- readr::read_csv(
    "./template_groupfile_output.csv",
    show_col_types = FALSE
  )
  
  output$template_Output_hover <- renderTable(
    template_output,
    bordered = TRUE,
    striped  = TRUE,
    rownames = FALSE,
    suspendWhenHidden = FALSE
  )
  
  output$template_Dataset_hover <- renderTable(
    template_data,
    bordered = TRUE,
    striped  = TRUE,
    rownames = FALSE,
    suspendWhenHidden = FALSE
  )
  
  # ---- Data load ----
  raw_df <- reactive({
    req(input$expression_dataframe)
    readr::read_csv(input$expression_dataframe$datapath, show_col_types = FALSE)
  })
  
  sample_choices <- reactive({
    req(raw_df())
    df <- raw_df()
    
    start <- input$data_start_col %||% 1
    start <- max(1, min(start, ncol(df)))  # clamp
    
    names(df)[start:ncol(df)]
  })
  
  token_delim_regex <- reactive({
    delims <- input$token_delims %||% c("_", "-")
    delims <- unique(delims)
    
    # If user unchecks everything, fall back to underscore+dash to avoid breaking
    if (!length(delims)) delims <- c("_", "-")
    
    # Escape for regex character class: -, ], \ need escaping; also handle dot/space
    escape_for_class <- function(x) {
      x <- gsub("\\\\", "\\\\\\\\", x)  # "\" -> "\\"
      x <- gsub("\\]", "\\\\]", x)
      x <- gsub("\\-", "\\\\-", x)
      x
    }
    
    cls <- paste0(vapply(delims, escape_for_class, character(1)), collapse = "")
    paste0("[", cls, "]+")
  })
  
  output$data_start_preview <- renderUI({
    req(raw_df())
    df <- raw_df()
    start <- input$data_start_col %||% 1
    start <- max(1, min(start, ncol(df)))
    
    nm <- names(df)
    preview <- paste0(
      paste(sprintf("%d:%s", seq_along(nm), nm), collapse = "  |  "),
      "\n\nSample columns will be: ", start, " .. ", ncol(df)
    )
    
    tags$pre(style="white-space: pre-wrap; font-size: 11px; color:#444; max-height:140px; overflow:auto;",
             preview)
  })
  
  output$gene_label_ui <- renderUI({
    req(raw_df())
    df <- raw_df()
    
    start <- input$data_start_col %||% 1
    start <- max(1, min(start, ncol(df)))
    
    ann_cols <- if (start > 1) names(df)[1:(start - 1)] else character(0)
    
    if (!length(ann_cols)) {
      return(helpText("No annotation columns detected (data starts at column 1), so gene labels will use row number."))
    }
    
    selectInput(
      "gene_label_col",
      "Gene label column (for preview plots)",
      choices  = ann_cols,
      selected = ann_cols[1]
    )
  })
  
  # ---- ID columns ----
  
  # ---- Groups: names & colors ----
  
  groups_rv <- reactiveVal(
    tibble(
      Group = paste0("Group ", 1:2),
      Color = c("#E86FDE", "#3CC9B9")
    )
  )
  
  # Adjust number of groups
  observeEvent(input$n_groups, {
    ng  <- input$n_groups %||% 1
    cur <- groups_rv()
    if (nrow(cur) < ng) {
      add <- tibble(
        Group = paste0("Group ", (nrow(cur) + 1):ng),
        Color = fallback_palette(ng - nrow(cur))
      )
      groups_rv(bind_rows(cur, add))
    } else if (nrow(cur) > ng) {
      groups_rv(cur[seq_len(ng), ])
    }
  }, ignoreInit = TRUE)
  
  # UI for group names/colors
  output$group_name_color_ui <- renderUI({
    ng <- input$n_groups %||% 1
    req(ng >= 1)
    
    df <- isolate(groups_rv())  # <- key change (no reactive dependency)
    
    # make sure df has ng rows (safety)
    if (nrow(df) < ng) {
      df <- bind_rows(df, tibble(
        Group = paste0("Group ", (nrow(df) + 1):ng),
        Color = fallback_palette(ng - nrow(df))
      ))
    } else if (nrow(df) > ng) {
      df <- df[seq_len(ng), ]
    }
    
    tagList(
      lapply(seq_len(ng), function(i){
        fluidRow(
          column(
            8,
            textInput(
              paste0("grp_name_", i),
              label = paste("Group", i, "name"),
              value = df$Group[i]
            )
          ),
          column(
            4,
            colourInput(
              paste0("grp_col_", i),
              label = "Color",
              value = df$Color[i],
              showColour = "both"
            )
          )
        )
      })
    )
  })
  
  # Sync group labels/colors from UI back into groups_rv (no resizing here)
  observe({
    df <- groups_rv()
    ng <- nrow(df)
    if (!ng) return()
    
    new_G <- df$Group
    new_C <- df$Color
    
    for (i in seq_len(ng)) {
      g_in <- input[[paste0("grp_name_", i)]]
      c_in <- input[[paste0("grp_col_", i)]]
      
      if (!is.null(g_in) && nzchar(g_in)) new_G[i] <- g_in
      if (!is.null(c_in) && nzchar(c_in)) new_C[i] <- c_in
    }
    
    groups_rv(tibble(Group = new_G, Color = new_C))
  })
  
  # Auto colors
  observeEvent(input$auto_colors, {
    df <- groups_rv(); req(nrow(df) > 0)
    df$Color <- fallback_palette(nrow(df))
    groups_rv(df)
    for (i in seq_len(nrow(df))) {
      updateColourInput(session, paste0("grp_col_", i), value = df$Color[i])
    }
  })
  
  # stash the token collectors
  # observe({
  #   grps <- groups_rv()
  #   req(nrow(grps) > 0)
  #   
  #   cur <- grp_rule_rv()
  #   
  #   for (i in seq_len(nrow(grps))) {
  #     gname <- grps$Group[i]
  #     
  #     toks <- input[[paste0("grp_tokens_", i)]]
  #     md   <- input[[paste0("grp_mode_",   i)]]
  #     
  #     if (!is.null(toks) || !is.null(md)) {
  #       cur[[gname]] <- list(
  #         tokens = toks %||% (cur[[gname]]$tokens %||% character(0)),
  #         mode   = md   %||% (cur[[gname]]$mode   %||% "all")
  #       )
  #     }
  #   }
  #   
  #   grp_rule_rv(cur)
  # })
  # stash the token collectors (AND-only; no mode)
  observe({
    grps <- groups_rv()
    req(nrow(grps) > 0)
    
    cur <- grp_rule_rv()
    
    for (i in seq_len(nrow(grps))) {
      gname <- grps$Group[i]
      
      toks <- input[[paste0("grp_tokens_", i)]]
      
      if (!is.null(toks)) {
        cur[[gname]] <- list(
          tokens = toks %||% (cur[[gname]]$tokens %||% character(0))
        )
      }
    }
    
    grp_rule_rv(cur)
  })
  
  # when tokens are deselected remove from the stash so that the UI updates accordingly
  observeEvent(groups_rv(), {
    grps <- groups_rv()$Group
    cur  <- grp_rule_rv()
    cur  <- cur[names(cur) %in% grps]
    grp_rule_rv(cur)
  }, ignoreInit = TRUE)
  
  # ---- Assignment table state ----
  
  assign_df <- reactiveVal(
    tibble(Sample = character(), Group = character(), Color = character())
  )
  
  token_choices <- reactive({
    df <- assign_df()
    req(nrow(df) > 0)
    
    # del <- input$token_delim %||% "[_\\.-]+"
    del <- token_delim_regex()
    
    toks_list <- str_split(df$Sample, pattern = del)
    
    toks <- unlist(lapply(toks_list, function(v) {
      v <- v[!is.na(v) & v != ""]
      v
    }))
    
    if (!length(toks)) return(character(0))
    
    tab <- table(toks)
    
    keep <- names(tab)
    sort(keep)
  })
  
  # Initialize assign_df when samples change
  observe({
    req(raw_df())
    samples <- sample_choices(); req(length(samples) > 0)
    df <- tibble(Sample = samples, Group = NA_character_, Color = NA_character_)
    assign_df(df)
    updateSelectInput(
      session, "bulk_group",
      choices = c("(Unassigned)" = UNASSIGNED_SENTINEL, groups_rv()$Group)
    )
  })
  
  # Final mapping used for viz/download
  final_group_df <- reactive({
    df <- assign_df()
    req(nrow(df) > 0)
    
    # Join to current group definitions for authoritative colors
    out <- df %>%
      left_join(groups_rv(), by = "Group") %>%
      mutate(
        Color = ifelse(!is.na(Color.y) & nzchar(Color.y), Color.y, Color.x)
      ) %>%
      select(Sample, Group, Color)
    
    out
  })
  
  # ---- Token-based helper text & auto-delim ----
  
  output$token_help <- renderUI({
    df <- assign_df()
    req(nrow(df) > 0)
    s <- paste(df$Sample, collapse = " ")
    txt <- if (grepl("_", s)) {
      "We detected your sample names use <code>_</code> as a separator. Using that to auto-group. <span style='font-size:11px;color:#777'>(Advanced: edit pattern)</span>"
    } else if (grepl("-", s)) {
      "We detected your sample names use <code>-</code> as a separator. Using that to auto-group. <span style='font-size:11px;color:#777'>(Advanced: edit pattern)</span>"
    } else if (grepl("\\.", s)) {
      "We detected your sample names use <code>.</code> as a separator. Using that to auto-group. <span style='font-size:11px;color:#777'>(Advanced: edit pattern)</span>"
    } else {
      "No clear separator detected. Defaulting to split on <code>_</code>, <code>-</code>, or <code>.</code>. <span style='font-size:11px;color:#777'>(Advanced: edit pattern)</span>"
    }
    HTML(txt)
  })
  
  observeEvent(assign_df(), {
    if (!is.null(input$token_delims) && length(input$token_delims)) return()
    
    df <- assign_df()
    if (nrow(df) == 0) return()
    
    s <- paste(df$Sample, collapse = " ")
    guess <- character(0)
    if (grepl("_", s)) guess <- c(guess, "_")
    if (grepl("-", s)) guess <- c(guess, "-")
    if (grepl("\\.", s)) guess <- c(guess, ".")
    if (grepl(" ", s)) guess <- c(guess, " ")
    
    if (!length(guess)) guess <- c("_", "-")
    
    updateCheckboxGroupInput(session, "token_delims", selected = unique(guess))
  }, ignoreInit = TRUE)
  
  # Token position selector
  output$token_dims_ui <- renderUI({
    tt <- tokens_tbl()
    req(nrow(tt) > 0)
    
    tcols <- grep("^T[0-9]+$", names(tt), value = TRUE)
    if (!length(tcols)) return(NULL)
    
    choices_list <- lapply(tcols, function(tc){
      vals <- unique(na.omit(tt[[tc]]))
      vals <- vals[vals != ""]
      if (length(vals) <= 1) return(NULL)  # skip non-informative
      
      lbl <- paste0(
        "Position ", sub("T", "", tc), " (",
        paste(head(vals, 4), collapse = " / "),
        if (length(vals) > 4) " / ..." else "",
        ")"
      )
      setNames(tc, lbl)
    })
    
    choices_vec <- do.call(c, choices_list)
    
    if (is.null(choices_vec) || !length(choices_vec)) {
      return(helpText("No informative token positions detected. Adjust the delimiter or sample names."))
    }
    
    selectInput(
      "token_dims",
      "Combine which token positions into groups?",
      choices = choices_vec,
      multiple = TRUE,
      selected = choices_vec[1]
    )
  })
  
  # observeEvent(input$apply_token, {
  #   df <- assign_df()
  #   req(nrow(df) > 0)
  #   
  #   grps <- groups_rv()
  #   req(nrow(grps) > 0)
  #   
  #   # del <- input$token_delim %||% "[_\\.-]+"
  #   del <- token_delim_regex()
  #   # Split sample names into tokens once
  #   toks_list <- str_split(df$Sample, pattern = del)
  #   sample_tokens <- lapply(toks_list, function(v) {
  #     unique(v[!is.na(v) & v != ""])
  #   })
  #   
  #   # Collect selected tokens per group
  #   grp_tokens <- lapply(seq_len(nrow(grps)), function(i) {
  #     sel <- input[[paste0("grp_tokens_", i)]]
  #     sel <- sel[!is.na(sel) & sel != ""]
  #     sel
  #   })
  #   names(grp_tokens) <- grps$Group
  #   
  #   # If no group has tokens, bail nicely
  #   if (all(vapply(grp_tokens, length, integer(1)) == 0)) {
  #     showModal(modalDialog(
  #       title = "No token rules defined",
  #       "Please select one or more tokens for at least one group before applying.",
  #       easyClose = TRUE
  #     ))
  #     return()
  #   }
  #   
  #   # Assign each sample to at most one group:
  #   # sample ∈ G if it contains ANY token in grp_tokens[G];
  #   # if multiple groups match, first (top-most) group wins.
  #   assigned_group <- rep(NA_character_, length(sample_tokens))
  #   
  #   grp_order <- grps$Group  # preserves UI order
  #   grp_rules <- lapply(seq_len(nrow(grps)), function(i) {
  #     gname <- grps$Group[i]
  #     list(
  #       name   = gname,
  #       tokens = (input[[paste0("grp_tokens_", i)]] %||% character(0)) |> unique(),
  #       mode   = input[[paste0("grp_mode_",   i)]] %||% "all"
  #     )
  #   })
  #   names(grp_rules) <- grp_order
  #   
  #   assigned_group <- vapply(sample_tokens, function(st) {
  #     scores <- vapply(grp_order, function(g) {
  #       toks <- grp_rules[[g]]$tokens
  #       md   <- grp_rules[[g]]$mode
  #       
  #       if (!length(toks)) return(-Inf)
  #       
  #       hit <- if (identical(md, "any")) any(toks %in% st) else all(toks %in% st)
  #       if (!hit) return(-Inf)
  #       
  #       # scoring: prefer AND-groups (more specific), then by number of tokens / matches
  #       if (identical(md, "all")) {
  #         1000 + length(toks)
  #       } else {
  #         sum(toks %in% st)  # "any" groups: more matched tokens = stronger match
  #       }
  #     }, numeric(1))
  #     
  #     if (all(!is.finite(scores))) return(NA_character_)
  #     grp_order[which.max(scores)]  # tie breaks by UI order because which.max picks first
  #   }, character(1))
  #   
  #   # Apply to df
  #   df$Group <- assigned_group
  #   
  #   # Map colors 1:1 from groups_rv
  #   color_map <- setNames(grps$Color, grps$Group)
  #   df$Color <- ifelse(
  #     is.na(df$Group),
  #     NA_character_,
  #     unname(color_map[df$Group])
  #   )
  #   
  #   assign_df(df)
  #   
  #   used_groups <- sort(unique(na.omit(df$Group)))
  #   # updateSelectInput(session, "bulk_group", choices = used_groups)
  #   updateSelectInput(
  #     session, "bulk_group",
  #     choices = c("(Unassigned)" = UNASSIGNED_SENTINEL, used_groups)
  #   )
  #   
  #   updateTabsetPanel(session, "tabs", selected = "Assignment table")
  # })
  
  observeEvent(input$apply_token, {
    df <- assign_df()
    req(nrow(df) > 0)
    
    grps <- groups_rv()
    req(nrow(grps) > 0)
    
    del <- token_delim_regex()
    
    # Split sample names into tokens once
    toks_list <- str_split(df$Sample, pattern = del)
    sample_tokens <- lapply(toks_list, function(v) {
      unique(v[!is.na(v) & v != ""])
    })
    
    # Collect selected tokens per group
    grp_tokens <- lapply(seq_len(nrow(grps)), function(i) {
      sel <- input[[paste0("grp_tokens_", i)]]
      sel <- sel[!is.na(sel) & sel != ""]
      sel
    })
    names(grp_tokens) <- grps$Group
    
    # If no group has tokens, bail nicely
    if (all(vapply(grp_tokens, length, integer(1)) == 0)) {
      showModal(modalDialog(
        title = "No token rules defined",
        "Please select one or more tokens for at least one group before applying.",
        easyClose = TRUE
      ))
      return()
    }
    
    # Build rules list (tokens only, AND semantics)
    grp_order <- grps$Group  # preserves UI order
    grp_rules <- lapply(seq_len(nrow(grps)), function(i) {
      gname <- grps$Group[i]
      list(
        name   = gname,
        tokens = (input[[paste0("grp_tokens_", i)]] %||% character(0)) |> unique()
      )
    })
    names(grp_rules) <- grp_order
    
    # Assign each sample to at most one group (AND only)
    assigned_group <- vapply(sample_tokens, function(st) {
      scores <- vapply(grp_order, function(g) {
        toks <- grp_rules[[g]]$tokens
        if (!length(toks)) return(-Inf)
        
        # AND: sample must contain all tokens
        hit <- all(toks %in% st)
        if (!hit) return(-Inf)
        
        # scoring: more tokens = more specific rule
        1000 + length(toks)
      }, numeric(1))
      
      if (all(!is.finite(scores))) return(NA_character_)
      grp_order[which.max(scores)]  # tie breaks by UI order
    }, character(1))
    
    # Apply to df
    df$Group <- assigned_group
    
    # Map colors 1:1 from groups_rv
    color_map <- setNames(grps$Color, grps$Group)
    df$Color <- ifelse(
      is.na(df$Group),
      NA_character_,
      unname(color_map[df$Group])
    )
    
    assign_df(df)
    
    used_groups <- sort(unique(na.omit(df$Group)))
    updateSelectInput(
      session, "bulk_group",
      choices = c("(Unassigned)" = UNASSIGNED_SENTINEL, used_groups)
    )
    
    updateTabsetPanel(session, "tabs", selected = "Assignment table")
  })
  
  # ---- Assignment table (manual edit + bulk) ----
  
  output$assign_dt <- renderDT({
    df <- assign_df()
    req(nrow(df) > 0)
    
    # Display-only copy
    display_df <- df
    display_df$Group[is.na(display_df$Group) | display_df$Group == ""] <- "Unassigned"
    
    datatable(
      display_df,
      selection = "multiple",
      rownames  = FALSE,
      options   = list(
        scrollX    = TRUE,
        pageLength = 200
      )
    ) %>%
      formatStyle(
        "Color",
        target = "cell",
        backgroundColor = styleEqual(
          unique(df$Color),
          unique(df$Color)
        )
      ) %>%
      formatStyle(
        "Group",
        color = styleEqual("Unassigned", "grey40"),
        fontStyle = styleEqual("Unassigned", "italic")
      )
  }, server = FALSE)
  
  # Bulk apply
  observeEvent(input$apply_bulk, {
    rows <- input$assign_dt_rows_selected
    grp  <- input$bulk_group
    req(length(rows) >= 1, !is.null(grp), nzchar(grp))
    
    df <- assign_df(); req(nrow(df) > 0)
    
    if (identical(grp, UNASSIGNED_SENTINEL)) {
      # Unassign: clear Group and Color
      df$Group[rows] <- NA_character_
      df$Color[rows] <- NA_character_
    } else {
      # Assign to a named group and set color from groups_rv
      df$Group[rows] <- grp
      df <- df %>%
        dplyr::left_join(groups_rv(), by = "Group") %>%
        dplyr::transmute(
          Sample,
          Group,
          Color = dplyr::if_else(
            !is.na(Color.y) & nzchar(Color.y),
            Color.y,
            Color.x
          )
        )
    }
    
    assign_df(df)
  })
  
  # ---- Visualization preview ---
  
  expr_long <- reactive({
    df <- raw_df(); req(df)
    
    samples <- sample_choices()
    req(length(samples) > 0)
    
    # pivot sample columns long
    df_long <- df %>%
      tidyr::pivot_longer(
        cols = dplyr::all_of(samples),
        names_to  = "Sample",
        values_to = "Count"
      )
    
    # gene label for plotting
    gl <- input$gene_label_col %||% "__ROW__"
    if (identical(gl, "__ROW__") || is.null(gl) || !gl %in% names(df)) {
      # row number (recycled across pivot rows)
      df_long$Gene <- rep(seq_len(nrow(df)), each = length(samples))
    } else {
      # chosen annotation column
      df_long$Gene <- rep(df[[gl]], each = length(samples))
    }
    
    df_long
  })
  
  
  viz_gene_choices <- reactive({
    df_long <- expr_long()
    
    # Make sure Count is numeric
    df_long$Count <- suppressWarnings(as.numeric(df_long$Count))
    
    # Average expression per gene across all selected samples
    gene_stats <- df_long %>%
      dplyr::group_by(Gene) %>%
      dplyr::summarize(
        mean_expr = mean(Count, na.rm = TRUE),
        .groups = "drop"
      )
    
    # Keep genes with mean expression >= 2
    keep <- gene_stats %>%
      dplyr::filter(!is.na(Gene), Gene != "", mean_expr >= 2) %>%
      dplyr::arrange(Gene) %>%
      dplyr::pull(Gene)
    
    # Fallback: if filtering nukes everything (weird file), return all valid genes
    if (!length(keep)) {
      keep <- df_long$Gene[!is.na(df_long$Gene) & df_long$Gene != ""]
      keep <- sort(unique(keep))
    }
    
    keep
  })
  
  output$viz_gene_ui <- renderUI({
    choices <- viz_gene_choices()
    req(length(choices) > 0)
    
    selectInput(
      "viz_gene",
      "Choose gene to preview:",
      choices = choices,
      selected = choices[1]
    )
  })
  
  output$viz_plot <- renderPlotly({
    # Long expression data
    expr <- expr_long()

    # Current mapping (Sample, Group, Color)
    map <- final_group_df()
    req(nrow(map) > 0)

    # Join to bring in Group/Color only for assigned samples
    df <- expr %>%
      inner_join(map, by = "Sample") %>%
      filter(!is.na(Group), !is.na(Color))
    req(nrow(df) > 0)

    # Ensure numeric
    df$Count <- suppressWarnings(as.numeric(df$Count))

    # Gene to show
    gene <- input$viz_gene %||% viz_gene_choices()[1]
    req(gene)

    gdat <- df %>% filter(Gene == gene)
    req(nrow(gdat) > 0)

    # Ordered groups in the order they appear
    grp_def <- groups_rv()
    req(nrow(grp_def) > 0)
    ordered_groups <- grp_def$Group[grp_def$Group %in% unique(gdat$Group)]
    gdat$Group <- factor(gdat$Group, levels = ordered_groups)

    # group -> color map (respect map)
    color_map <- setNames(
      map$Color[match(ordered_groups, map$Group)],
      ordered_groups
    )

    p <- plot_ly()

    for (grp in ordered_groups) {
      sub <- gdat[gdat$Group == grp, , drop = FALSE]
      col <- unname(color_map[[grp]])

      hover_txt <- paste0(
        "<b>Sample</b>: ", sub$Sample,
        "<br><b>Group</b>: ", sub$Group,
        "<br><b>Expr</b>: ", signif(sub$Count, 4)
      )

      # Box trace
      p <- p %>%
        add_trace(
          data = sub,
          x = ~Group,
          y = ~Count,
          type = "box",
          name = grp,
          # marker = list(color = I(col)),
          # line   = list(color = col),
          color = I(col),
          boxpoints = "outliers",
          hoverinfo = "y+name",
          showlegend = FALSE
        )

      # Overlay points (like bulk app)
      p <- p %>%
        add_trace(
          data = sub,
          x = ~Group,
          y = ~Count,
          type = "scatter",
          mode = "markers",
          marker = list(color = col, size = 8, opacity = 0.7),
          text = hover_txt,
          hoverinfo = "text",
          showlegend = FALSE
        )
    }

    upper_lim <- suppressWarnings(max(gdat$Count, na.rm = TRUE))
    if (!is.finite(upper_lim)) upper_lim <- NULL

    p %>%
      layout(
        title = list(
          text = paste0("<span style='color:blue;'>", gene, "</span>"),
          x = 0.5,
          xanchor = "center",
          font = list(size = 20)
        ),
        xaxis = list(
          title = "",
          categoryorder = "array",
          categoryarray = ordered_groups
        ),
        yaxis = list(
          title = "Expression (units from uploaded file)",
          zeroline = TRUE,
          zerolinewidth = 2,
          zerolinecolor = "#000000",
          range = if (!is.null(upper_lim)) c(0, upper_lim * 1.05) else NULL
        ),
        margin = list(t = 80, b = 80, l = 80, r = 40)
      )
  })


  # output$token_group_selectors <- renderUI({
  #   req(input$group_mode == "token")
  #   choices <- token_choices()
  #   req(length(choices) > 0)
  #   
  #   grps <- groups_rv()
  #   req(nrow(grps) > 0)
  #   
  #   saved <- isolate(grp_rule_rv())
  #   
  #   tagList(
  #     lapply(seq_len(nrow(grps)), function(i) {
  #       gname <- grps$Group[i]
  #       pre_tokens <- saved[[gname]]$tokens %||% character(0)
  #       pre_mode   <- saved[[gname]]$mode   %||% "all"
  #       
  #       div(
  #         tags$b(gname),
  #         
  #         radioButtons(
  #           inputId = paste0("grp_mode_", i),
  #           label   = NULL,
  #           choices = c("All tokens (AND)" = "all", "Any token (OR)" = "any"),
  #           selected = pre_mode,
  #           inline = TRUE
  #         ),
  #         
  #         selectizeInput(
  #           inputId = paste0("grp_tokens_", i),
  #           label = NULL,
  #           choices = choices,
  #           selected = pre_tokens,
  #           multiple = TRUE,
  #           options = list(plugins = list("remove_button"),
  #                          placeholder = "Select tokens for this group")
  #         ),
  #         
  #         tags$hr(style = "margin:4px 0;")
  #       )
  #     })
  #   )
  # })
  output$token_group_selectors <- renderUI({
    req(input$group_mode == "token")
    choices <- token_choices()
    req(length(choices) > 0)
    
    grps <- groups_rv()
    req(nrow(grps) > 0)
    
    saved <- isolate(grp_rule_rv())
    
    tagList(
      lapply(seq_len(nrow(grps)), function(i) {
        gname <- grps$Group[i]
        pre_tokens <- saved[[gname]]$tokens %||% character(0)
        
        div(
          tags$b(gname),
          
          # AND-only: just choose tokens, no mode toggle
          selectizeInput(
            inputId  = paste0("grp_tokens_", i),
            label    = NULL,
            choices  = choices,
            selected = pre_tokens,
            multiple = TRUE,
            options  = list(
              plugins    = list("remove_button"),
              placeholder = "Select tokens for this group"
            )
          ),
          
          tags$hr(style = "margin:4px 0;")
        )
      })
    )
  })
  
  # ---- Download groupfile ----
  ordered_groups_current <- function(map_df) {
    grp_def <- groups_rv()
    lev <- grp_def$Group[grp_def$Group %in% unique(map_df$Group)]
    lev[!is.na(lev) & nzchar(lev)]
  }
  
  output$download_groupfile <- downloadHandler(
    # filename = function() {
    #   paste0("groupfile_", format(Sys.time(), "%Y%m%d-%H%M%S"), ".csv")
    # },
    filename = function() {
      nm <- input$groupfile_name %||% ""
      nm <- trimws(nm)
      
      # if blank, keep your timestamp default
      if (!nzchar(nm)) {
        return(paste0("groupfile_", format(Sys.time(), "%Y%m%d-%H%M%S"), ".csv"))
      }
      
      # sanitize: keep letters, numbers, underscore, dash, dot; convert spaces to _
      nm <- gsub("\\s+", "_", nm)
      nm <- gsub("[^A-Za-z0-9._-]", "", nm)
      
      # ensure .csv
      if (!grepl("\\.csv$", nm, ignore.case = TRUE)) nm <- paste0(nm, ".csv")
      nm
    },
    content = function(file) {
      df <- assign_df(); req(nrow(df) > 0)
      
      # ensure required columns exist
      out <- df %>% dplyr::transmute(Sample, Group, Color)
      
      # validations
      if (any(!nzchar(out$Sample))) stop("Empty sample names present.")
      if (any(!nzchar(out$Group)))  stop("Some samples are unassigned to any group.")
      if (any(!nzchar(out$Color)))  stop("Some samples are missing colors.")
      
      # --- enforce the same order as preview / boxplot ---
      lev <- ordered_groups_current(out)        # UI group order
      if (length(lev)) {
        sample_order <- assign_df()$Sample      # on-screen sample order
        out$Group  <- factor(out$Group,  levels = lev)
        out$Sample <- factor(out$Sample, levels = sample_order)
        out <- out %>% dplyr::arrange(Group, Sample)
        # drop factor types for clean CSV
        out$Group  <- as.character(out$Group)
        out$Sample <- as.character(out$Sample)
      }
      
      readr::write_csv(out, file)
    }
  )
}

shinyApp(
  ui = ui,
  server = server
)